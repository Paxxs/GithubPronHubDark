export declare namespace httpclient {
    /**
     * In order to be an HttpClient, the class should:
     * Make a call to the server and returning a response
     * Make a simpler call to the server that only returns a part of the response
     * Add a filter to its filter list
     */
    interface HttpClient {
        executeForResponse<T>(request: Request): Promise<Response<T>>;
        callForResponse<T>(request: Request): Promise<Response<T>>;
        execute<T>(request: Request): Promise<T>;
        call<T>(request: Request): Promise<T>;
        addFilter(filter: Filter<any, any>, name: string, config?: FilterConfig): FilterRegistration;
    }
    interface Headers {
        [name: string]: string;
    }
    class Request {
        private _xhr;
        private aborted;
        xhr: XMLHttpRequest | undefined;
        readonly isAborted: boolean;
        abort(): void;
        upload: {
            onprogress: {
                (event: Event): void;
            };
            onloadstart: {
                (event: Event): void;
            };
        };
        url: string;
        contentType: string;
        method: 'GET' | 'POST' | 'PUT' | 'DELETE' | string;
        responseType: XMLHttpRequestResponseType;
        withCredentials: boolean;
        body?: object | Document | BodyInit | null;
        headers: Headers;
        timeout: number;
        readyState: number;
        properties: {
            [key: string]: any;
        };
        constructor(url: string, { contentType, method, responseType, withCredentials, body, headers, timeout }?: {
            contentType?: string;
            method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | string;
            responseType?: XMLHttpRequestResponseType;
            withCredentials?: boolean;
            body?: object | Document | BodyInit | null;
            headers?: Headers;
            timeout?: number;
        });
        set({ contentType, method, responseType, withCredentials, body, headers, timeout }: {
            contentType?: string;
            method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | string;
            responseType?: XMLHttpRequestResponseType;
            withCredentials?: boolean;
            body?: object | Document | BodyInit | null;
            headers?: Headers;
            timeout?: number;
        }): Request;
        setContentType(contentType: string): Request;
        setMethod(method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | string): Request;
        setResponseType(responseType: XMLHttpRequestResponseType): this;
        setWithCredentials(withCredentials: boolean): this;
        setBody(body?: object | Document | BodyInit | null): this;
        setHeaders(headers: Headers): this;
        addHeader(headerName: string, value: string): void;
        setTimeout(timeout: number): this;
        setProperty(key: string, value: any): this;
        getProperty(key: string): any;
    }
    class Response<T> {
        readonly request: Request;
        readonly status: number;
        readonly statusText: string;
        readonly headers: Headers;
        readonly body: T | null;
        readonly properties: {
            [key: string]: any;
        };
        constructor(request: Request, status: number, statusText: string, headers: Headers, body: T | null);
        setProperty(key: string, value: any): this;
        getProperty(key: string): any;
    }
    /**
     * Interface useful to remove a Filter after it has been added to the httpClient array
     */
    interface FilterRegistration {
        remove(): void;
    }
    /**
     * A FilterChain should have a method to apply all its filters
     * on a Request and send it to the server
     */
    interface FilterChain<T> {
        doFilter(call: Request): Promise<Response<T>>;
    }
    class FilterCollection implements Filter<any, any> {
        readonly filters: InstalledFilter[];
        constructor(filters: InstalledFilter[]);
        /**
         * @param call Is the request we want to modify
         * @param filterChain is an Interface that is a Filter, but its goal is to simulate
         * nested filters. So it contains an array of filter and its doFilter loops through all its filters
         * before continuing with the main chain of filters
         */
        doFilter(call: Request, filterChain: FilterChain<any>): Promise<Response<any>>;
    }
    /**
     * Is composed of a FilterConfig that checks the request to know if the Filter should be applied
     * and of a Filter that does something to the request/response
     */
    class InstalledFilter {
        readonly filter: Filter<any, any>;
        readonly name: string;
        readonly config?: FilterConfig | undefined;
        constructor(filter: Filter<any, any>, name: string, config?: FilterConfig | undefined);
    }
    interface FilterConfig {
        enabled(call: Request): boolean;
    }
    interface Filter<T, U> {
        doFilter(call: Request, filterChain: FilterChain<T>): Promise<Response<U>>;
    }
    function newHttpClient(): HttpClient;
}
